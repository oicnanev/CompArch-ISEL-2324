P16 assembler v1.5 (Feb  9 2024)	g02_tp1.lst	Sun Mar 17 16:48:07 2024

Sections
Index   Name            Address   Size
0       .startup        0000      0012 18
1       .text           0012      007A 122
2       .data           008C      0017 23
3       .stack          00A4      0040 64

Symbols
Name                    Type      Value       Section
_start                  LABEL     0004 4      .startup
ambar_scale             LABEL     0086 134    .text
AMBAR_SCALE             ABSOLUTE  0001 1      .startup
color_hist_addr         LABEL     0032 50     .text
color_histogram         LABEL     00A0 160    .data
color_scale             LABEL     0068 104    .text
color_scale_end         LABEL     0088 136    .text
CRITICAL_TIME           ABSOLUTE  0096 150    .startup
end_for                 LABEL     005E 94     .text
end_while_main          LABEL     0028 40     .text
for                     LABEL     004A 74     .text
GREEN_SCALE             ABSOLUTE  0000 0      .startup
line#29                 LABEL     0002 2      .startup
line#36                 LABEL     000C 12     .startup
main                    LABEL     0012 18     .text
main_addr               LABEL     0010 16     .startup
RED_SCALE               ABSOLUTE  0002 2      .startup
red_scale               LABEL     0082 130    .text
stack_bottom            LABEL     00A4 164    .stack
STACK_SIZE              ABSOLUTE  0040 64     .startup
stack_top               LABEL     00E4 228    .stack
stack_top_addr          LABEL     000E 14     .startup
test_color_scale        LABEL     0036 54     .text
times                   LABEL     008C 140    .data
times_addr              LABEL     0034 52     .text
WARNING_TIME            ABSOLUTE  012C 300    .startup
while_main              LABEL     001E 30     .text

Code listing
   1           	; -----------------------------------------------------------------------------
   2           	; File:         g02_tp1.S
   3           	; Description:  Support program for the realization of the 1st practical 
   4           	;               assignment of Computer Architecture.
   5           	; Authors:      45824 Nuno Venâncio
   6           	;               48070 Daniel Cabaça
   7           	; Date:         2024-03-17
   8           	; -----------------------------------------------------------------------------
   9           	
  10           	; Setting the values for symbols (constants) used in the program ==============
  11           	
  12          	.equ    STACK_SIZE, 64
  13          	.equ    RED_SCALE, 2            ; unsigned 8 bit
  14          	.equ    AMBAR_SCALE, 1          ; unsigned 8 bit
  15          	.equ    GREEN_SCALE, 0          ; unsigned 8 bit
  16          	.equ    WARNING_TIME, 300       ; signed 16 bit
  17          	.equ    CRITICAL_TIME, 150      ; signed 16 bit
  18           	
  19           	; =============================================================================
  20           	
  21           	
  22           	
  23           	; Section:    .startup ========================================================
  24           	; Description: Exception / Interrupt vector table
  25           	
  26           	    .section .startup
  27           	
  28 0000 01 58	    b		_start					; Reset handler
  29 0002 FF 5B	    b		.						; Interrupt handler
  30           	
  31           	_start:
  32 0004 4D 0C	    ldr		SP, stack_top_addr	; Initialize the stack pointer
  33 0006 80 B7	    mov		R0, PC					; The next intruction only allows R0..R7 in the 2nd operand
  34 0008 0E A2	    add		LR, R0, #4				; Set LR to after the call to main
  35 000A 2F 0C	    ldr		PC, main_addr			; Set PC to begining of main address
  36 000C FF 5B	    b		.
  37           	
  38           	stack_top_addr:
  39 000E E4 00	    .word   stack_top
  40           	
  41           	main_addr:
  42 0010 12 00	    .word   main
  43           	
  44           	; =============================================================================
  45           	
  46           	
  47           	
  48           	; Section:    .text ===========================================================
  49           	; Description: Program code
  50           	
  51           	    .text
  52           	
  53           	; Routine:      main ----------------------------------------------------------
  54           	; Description:
  55           	; Inputs:       none
  56           	; Outputs:      value 0
  57           	; Efects:
  58           	
  59           	main:
  60           	    ; save used registers in stack 
  61 0012 0E 24	    push	LR
  62           	
  63 0014 00 60	    mov		R0, #0 & 0xFF			; i = 0 (uint16_t) - lsb
  64 0016 00 70	    movt	R0, #(0>>8) & 0xFF		; i = 0 - msb
  65           	
  66 0018 C1 0C	    ldr		R1, color_hist_addr	; get color_histogram mem address
  67 001A 02 60	    mov		R2, #0					; color_histogram index value, 8bit
  68 001C 33 60	    mov		R3, #3					; temp value for while_main
  69           	    
  70           	while_main:
  71           	    ; while ( i < 3 )
  72 001E 80 B9	    cmp		R0, R3					; check if i >= 3
  73 0020 03 48	    bhs		end_while_main
  74 0022 12 38	    strb	R2, [R1, R0]			; set 0 (8 bit R2) in color_histogram mem addr R1, idx R0
  75 0024 80 A0	    add		R0, R0, #1				; i++
  76 0026 FB 5B	    b		while_main
  77           	
  78           	end_while_main:
  79           	    ; call to test_color_scale( times(R0), color_histogram(R1), 10(R2) )
  80 0028 50 0C	    ldr		R0, times_addr		; R0 = times mem address
  81 002A A2 60	    mov		R2, #10					; R2 = 10
  82 002C 04 5C	    bl		test_color_scale		; R1 already has color_hist_addr
  83           	
  84 002E 00 60	    mov		R0, #0					; return 0
  85           		
  86 0030 0F 04	    pop		PC						; put LR in PC
  87           	
  88           	
  89           	color_hist_addr:
  90 0032 A0 00	    .word color_histogram
  91           	
  92           	times_addr:
  93 0034 8C 00	    .word times
  94           	
  95           	
  96           	
  97           	; Routine:      test_color_scale ----------------------------------------------
  98           	; Description:  
  99           	; Inputs:       times (uint16_t array address in R0)
 100           	;               color_histogram (uint8_t array address in R1)
 101           	;               size (int16_t in R2)   
 102           	; Outputs:      None
 103           	; Efects:       Fills the color_histogram array
 104           	
 105           	test_color_scale:
 106 0036 0E 24	    push	LR
 107 0038 04 24	    push	R4
 108 003A 05 24	    push	R5
 109 003C 06 24		push	R6
 110 003E 07 24		push	R7
 111           	
 112 0040 03 60	    mov		R3, #0 & 0xFF			; i = 0 (int16_t) - lsb
 113 0042 03 70	    movt	R3, #0 >> 8 & 0xFF		; i = 0 - msb
 114 0044 04 B0	    mov		R4, R0					; preserve R0, array_t times address
 115 0046 85 B0	    mov		R5, R1					; preserve R1	, array_c color_histogram address
 116 0048 06 B1		mov		R6, R2					; preserve R2, array_t size, 10
 117           	
 118           	for:
 119 004A 30 BB	    cmp		R3, R6  				; compare value i with 10
 120 004C 08 48	    bhs		end_for
 121 004E B7 81		add   	R7, R3, R3				; array_t index must be incremented by 2
 122 0050 C0 13		ldr     R0, [R4, R7]			; array_t[i] (times) value
 123 0052 0A 5C	    bl		color_scale			; call to color_scale, result comes in R0
 124 0054 51 18	    ldrb	R1, [R5, R0]			; array_c[color_scale(array_t)] value
 125 0056 91 A0	    add		R1, R1, #1				; array_c[color_scale(array_t)] value ++
 126 0058 51 38	    strb	R1, [R5, R0]			; save the new value
 127 005A B3 A0		add 	R3, R3, #1				; i++
 128 005C F6 5B	    b		for
 129           	
 130           	end_for:
 131 005E 07 04		pop 	R7
 132 0060 06 04		pop		R6
 133 0062 05 04	    pop		R5
 134 0064 04 04	    pop		R4
 135 0066 0F 04	    pop		PC
 136           	
 137           	
 138           	
 139           	; Routine:      color_scale ---------------------------------------------------
 140           	; Description:  returns a color value (0, 1, 2) according the t value
 141           	; Inputs:       t (uint16_t in R0)
 142           	; Outputs:      t (uint8_t in R0 )
 143           	; Efects:
 144           	
 145           	color_scale:    
 146 0068 04 24	    push	R4						; save used registers in stack
 147           	
 148 006A 04 B0	    mov		R4, R0					; preserve t
 149           	
 150 006C 00 60	    mov		R0, #GREEN_SCALE & 0xFF
 151 006E 00 70		movt 	R0, #GREEN_SCALE >> 8 & 0xFF
 152 0070 61 69	    mov		R1, #CRITICAL_TIME & 0xFF
 153 0072 01 70	    movt	R1, #CRITICAL_TIME >> 8 & 0xFF
 154 0074 C2 62	    mov		R2, #WARNING_TIME & 0xFF
 155 0076 12 70	    movt	R2, #WARNING_TIME >> 8 & 0xFF
 156           	
 157           	    ; t >= CRITICAL_TIME && t <= WARNING_TIME
 158 0078 C0 B8	    cmp		R4, R1
 159 007A 03 4C	    blo		red_scale				; t is < CRITICAL_TIME
 160 007C 20 BA	    cmp		R2, R4					; WARNING_TIME > t
 161 007E 03 48	    bhs		ambar_scale			; t is >= CRITICAL_TIME and <= WARNING_TIME
 162 0080 03 58	    b		color_scale_end		; t is > WARNING_TIME
 163           	
 164           	red_scale:
 165 0082 20 60	    mov		R0, #RED_SCALE
 166 0084 01 58	    b		color_scale_end
 167           	
 168           	ambar_scale:
 169 0086 10 60	    mov		R0, #AMBAR_SCALE
 170           	
 171           	color_scale_end:
 172 0088 04 04	    pop		R4
 173 008A 0F B7	    mov		PC, LR
 174           	
 175           	; =============================================================================
 176           	
 177           	
 178           	
 179           	; Section:    .data ===========================================================
 180           	; Description: Saves global variables
 181           	    .data
 182           	
 183           	times:
 184          	    .word 65535, 500, 301, 300, 299, 151, 150, 149, 1, 0
 184 008C FF FF F4 01 2D 01 2C 01 2B 01 97 00 96 00 95 00
 184 009C 01 00 00 00
 185           	
 186           	color_histogram:
 187 00A0 00   	    .space 3
 187 00A1 00
 187 00A2 00
 188           	
 189           	; =============================================================================
 190           	
 191           	
 192           	
 193           	; Section:    .stack ==========================================================
 194           	; Description: Implements the stack with the size defined by the symbol STACK_SIZE
 195           	;
 196           	    .stack
 197           	stack_bottom:
 198 00A4 00   	    .space  STACK_SIZE
 198 .... ..
 198 00E3 00
 199           	stack_top:
 200           	
 201           	
 202           	
 203           	; Assignment question responses in portuguese ==================================
 204           	;
 205           	; 1. b) 
 206           	; O número de bytes necessários, em termos de requisitos de memória para para a
 207           	; implementação dos símbolos RED_SCALE, AMBAR_SCALE, GREEN_SCALE, WARNING_TIME e
 208           	; CRITICAL_TIME, são 0 bytes, uma vez que estes símbolos são definidos com .equ e
 209           	; o assembler, substitui o valor definido nos .equ nos locais onde são referidos
 210           	; na implementação do código na secção .text
 211           	;
 212           	; 2. 
 213           	; Todas as varáveis globais (as arrays 'times' e 'color_histogram') foram implementadas
 214           	; na secção .data porque esta secção é a aquela que é reponsável no P16 para guardar
 215           	; tanto as varáveis com valor préviamente definido ('times') como as varáveis sem valor 
 216           	; previamente definido ('color_histogram')
 217           	;
 218           	; 3. 
 219           	; b) A nossa implementação ocupa 36 bytes de memória, dos endereços 0x0068 ao 0x008A,
 220           	;
 221           	; 4. a) 
 222           	; A afirmação referida não está correta uma vez que o registo R4 é um registo que tem de
 223           	; ser preservado (push / pop) enquanto que o registo R3, por convenção, pode ser usado
 224           	; sem ser necessária a sua preservação.
 224           	
