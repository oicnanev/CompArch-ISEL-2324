P16 assembler v1.5 (Feb  9 2024)	traffic_lights_v3.lst	Fri May 31 16:32:28 2024

Sections
Index   Name            Address   Size
0       startup         0000      0014 20
1       .text           0014      02C8 712
2       .data           02DC      0024 36
3       .stack          0300      0040 64

Symbols
Name                    Type      Value       Section
_start                  LABEL     0004 4      startup
BLINK_TIME              ABSOLUTE  0005 5      startup
check_pedestrian_button LABEL     01E0 480    .text
conf_first_time_on_phase LABEL     02FF 767    .data
conf_first_time_on_phase_addr LABEL     01A8 424    .text
conf_leds_phase         LABEL     02FE 766    .data
conf_leds_phase_addr    LABEL     01AC 428    .text
config_mode             LABEL     011A 282    .text
config_mode_end         LABEL     015A 346    .text
config_mode_leds_on_phase LABEL     0154 340    .text
config_mode_leds_phase_end LABEL     01A2 418    .text
config_mode_leds_phases LABEL     0168 360    .text
CONFIG_SW               ABSOLUTE  0010 16     startup
config_time_start_tick  LABEL     02FC 764    .data
config_time_start_tick_addr LABEL     01AA 426    .text
CPSR_BIT_I              ABSOLUTE  0010 16     startup
crossing_time           LABEL     02E0 736    .data
crossing_time_addr      LABEL     01DE 478    .text
crossing_time_addr0     LABEL     00D2 210    .text
crossing_time_start_tick LABEL     02F4 756    .data
crossing_time_start_tick_addr LABEL     0118 280    .text
crossing_times_array    LABEL     02E2 738    .data
crossing_times_array_addr LABEL     01DC 476    .text
end_operation_mode      LABEL     00CA 202    .text
first_time_on_op        LABEL     02F8 760    .data
get_config_sw           LABEL     01EA 490    .text
GREEN                   ABSOLUTE  0002 2      startup
in_config               LABEL     02FB 763    .data
in_config_addr          LABEL     0162 354    .text
in_config_addr0         LABEL     0098 152    .text
in_crossing             LABEL     02F2 754    .data
in_crossing_addr        LABEL     0166 358    .text
in_crossing_addr0       LABEL     00D0 208    .text
in_operation            LABEL     02F3 755    .data
in_operation_addr       LABEL     0164 356    .text
in_operation_addr0      LABEL     0096 150    .text
inport_addr             LABEL     0260 608    .text
INPORT_ADDRESS          ABSOLUTE  FF80 65408  startup
inport_read             LABEL     025A 602    .text
isr                     LABEL     01AE 430    .text
isr_addr                LABEL     0012 18     startup
led_on_phase            LABEL     008E 142    .text
LIGHT_OFF               ABSOLUTE  0000 0      startup
line#53                 LABEL     000C 12     startup
line#94                 LABEL     0036 54     .text
main                    LABEL     0014 20     .text
main_addr               LABEL     0010 16     startup
main_config_mode        LABEL     0032 50     .text
main_loop               LABEL     0024 36     .text
MODE_LIGHT              ABSOLUTE  0030 48     startup
mode_light_set_color    LABEL     0228 552    .text
not_first_time_in_config_mode LABEL     0144 324    .text
not_first_time_in_operation_mode LABEL     005C 92     .text
not_first_time_in_phase LABEL     0188 392    .text
not_first_time_on_op    LABEL     007E 126    .text
op_first_time_on_phase  LABEL     02FA 762    .data
op_first_time_on_phase_addr LABEL     0108 264    .text
op_first_time_on_phase_addr0 LABEL     009A 154    .text
op_led_phase            LABEL     02F9 761    .data
op_led_phase_addr       LABEL     010A 266    .text
op_led_phase_addr0      LABEL     009E 158    .text
op_not_first_time_in_phase LABEL     00E8 232    .text
operation_mode          LABEL     0038 56     .text
operation_mode_led_phases LABEL     00D4 212    .text
operation_mode_led_phases_end LABEL     0102 258    .text
operation_time_start_tick LABEL     02F6 758    .data
operation_time_start_tick_addr LABEL     0116 278    .text
operation_time_start_tick_addr0 LABEL     009C 156    .text
outport_addr            LABEL     02A6 678    .text
OUTPORT_ADDRESS         ABSOLUTE  FFC0 65472  startup
outport_clear_bits      LABEL     0270 624    .text
outport_img             LABEL     02DC 732    .data
outport_img_addr        LABEL     02A8 680    .text
outport_init            LABEL     0280 640    .text
outport_set_bits        LABEL     0262 610    .text
outport_write           LABEL     029C 668    .text
outport_write_bits      LABEL     028A 650    .text
pedestrian_ask_to_cross LABEL     00A0 160    .text
PEDESTRIAN_BUTTON       ABSOLUTE  0001 1      startup
pedestrian_crossing     LABEL     00B0 176    .text
PEDESTRIAN_LIGHT        ABSOLUTE  000C 12     startup
pedestrian_light_set_color LABEL     021C 540    .text
pedestrian_time_finished LABEL     00C6 198    .text
PTC_ADDR                LABEL     02DA 730    .text
ptc_addr                LABEL     01C4 452    .text
ptc_addr0               LABEL     02BC 700    .text
PTC_ADDRESS             ABSOLUTE  FF40 65344  startup
ptc_clr_irq             LABEL     02D4 724    .text
PTC_CMD_START           ABSOLUTE  0000 0      startup
PTC_CMD_STOP            ABSOLUTE  0001 1      startup
ptc_get_value           LABEL     02CE 718    .text
ptc_init                LABEL     02AA 682    .text
ptc_start               LABEL     02BE 702    .text
ptc_stop                LABEL     02C6 710    .text
PTC_TC                  ABSOLUTE  0004 4      startup
PTC_TCR                 ABSOLUTE  0000 0      startup
PTC_TIR                 ABSOLUTE  0006 6      startup
PTC_TMR                 ABSOLUTE  0002 2      startup
RED                     ABSOLUTE  0001 1      startup
set_crossing_time       LABEL     01C8 456    .text
STACK_SIZE              ABSOLUTE  0040 64     startup
stack_top               LABEL     0340 832    .stack
stack_top_addr          LABEL     000E 14     startup
start_pedestrian_timmer LABEL     010C 268    .text
sw_is_pressed           LABEL     01F6 502    .text
sw_is_pressed_0         LABEL     020C 524    .text
sw_is_pressed_end       LABEL     020E 526    .text
sw_state                LABEL     02DD 733    .data
sw_state_addr           LABEL     0210 528    .text
sysclk                  LABEL     02DE 734    .data
sysclk_addr             LABEL     0258 600    .text
sysclk_addr0            LABEL     01C6 454    .text
sysclk_elapsed          LABEL     0250 592    .text
SYSCLK_FREQ             ABSOLUTE  0063 99     startup
sysclk_get_ticks        LABEL     024A 586    .text
sysclk_init             LABEL     0234 564    .text
TIME_SWS                ABSOLUTE  00E0 224    startup
TRAFFIC_LIGHT           ABSOLUTE  0003 3      startup
traffic_light_set_color LABEL     0212 530    .text
YELLOW                  ABSOLUTE  0003 3      startup

Code listing
   1           	; Definicao dos valores dos simbolos utilizados no programa
   2          	    .equ    CPSR_BIT_I, 0b010000        ; Mascara para o bit I do registo CPSR
   3          	    .equ    STACK_SIZE, 64              ; Dimensao do stack - 64 B
   4           	
   5           	    ; Definicoes do porto de entrada    ----------------------------------------
   6          	    .equ    INPORT_ADDRESS, 0xFF80      ; Endereco do porto de entrada
   7          	    .equ    PEDESTRIAN_BUTTON, 0x01     ; Mascara para botão de peão
   8          	    .equ    CONFIG_SW, 0x10             ; Mascara para switch de CONFIG
   9          	    .equ    TIME_SWS, 0xE0              ; Mascara para Time
  10           	
  11           	    ; Definicoes do porto de saida      ----------------------------------------  
  12          	    .equ    OUTPORT_ADDRESS, 0xFFC0     ; Endereco do porto de saida
  13          	    .equ    TRAFFIC_LIGHT, 0x03         ; Mascara para semáforo de trânsito
  14          	    .equ    PEDESTRIAN_LIGHT, 0x0C      ; Mascara para semáforo de peões
  15          	    .equ    MODE_LIGHT, 0x30            ; Mascara para semáforo de modo
  16           	
  17           	    ; Definicoes do circuito pTC        ----------------------------------------
  18          	    .equ    PTC_ADDRESS,  0xFF40        ; Endereco do circuito pTC
  19          	    .equ    PTC_TCR, 0                  ; Deslocamento do registo TCR do pTC
  20          	    .equ    PTC_TMR, 2                  ; Deslocamento do registo TMR do pTC
  21          	    .equ    PTC_TC,  4                  ; Deslocamento do registo TC do pTC
  22          	    .equ    PTC_TIR, 6                  ; Deslocamento do registo TIR do pTC
  23          	    .equ    PTC_CMD_START, 0            ; Comando para iniciar a contagem no pTC
  24          	    .equ    PTC_CMD_STOP, 1             ; Comando para parar a contagem no pTC
  25          	    .equ    SYSCLK_FREQ, 0x63           ; Intervalo de contagem do circuito pTC
  26           	                                        ; que suporta a implementação do sysclk
  27           	                                        ; T = 1 / f  
  28           	                                        ; 0.001s = 1 / 1000Hz
  29           	                                        ; 0.1s   = 1 / f ( f = 10Hz )
  30           	                                        ; 1000Hz / 10Hz = 100Hz = 0x64
  31           	    ;.equ    SYSCLK_FREQ, 0x01           ; PARA O SIMULADOR APAGAR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  32           	
  33           	    ; Outras definicoes                 ----------------------------------------
  34          	    .equ    BLINK_TIME, 0x05            ; Tempo dos LEDs intermitentes 
  35          	    .equ    RED, 0x01                   ; Mascara para o LED vermelho
  36          	    .equ    GREEN, 0x02                 ; Mascara para o LED verde
  37          	    .equ    YELLOW, 0x03                ; Mascara para o LED amarelo
  38          	    .equ    LIGHT_OFF, 0x00             ; Mascara para apagar os LEDs
  39           	 
  40           	
  41           	; ##############################################################################
  42           	; Seccao:    startup
  43           	; Descricao: Guarda o código de arranque do sistema
  44           	;
  45           	    .section startup
  46 0000 01 58	    b       _start
  47 0002 7F 0C	    ldr     pc, isr_addr
  48           	_start:
  49 0004 4D 0C	    ldr     sp, stack_top_addr
  50 0006 80 B7	    mov     r0, pc
  51 0008 0E A2	    add     lr, r0, #4
  52 000A 2F 0C	    ldr     pc, main_addr
  53 000C FF 5B	    b       .
  54           	
  55           	stack_top_addr:
  56 000E 40 03	    .word   stack_top
  57           	main_addr:
  58 0010 14 00	    .word   main
  59           	isr_addr:
  60 0012 AE 01	    .word   isr
  61           	
  62           	; ##############################################################################
  63           	; Seccao:    text
  64           	; Descricao: Guarda o código do programa
  65           	;
  66           	    .text
  67           	
  68           	; Rotina:    main --------------------------------------------------------------
  69           	; Descricao: *** TODO ***
  70           	; Entradas:  -
  71           	; Saidas:    -
  72           	; Efeitos:   *** TODO ***
  73           	main:
  74 0014 00 60	    mov     r0, #0                      ; todos os LEDs apagados
  75 0016 34 5D	    bl      outport_init
  76 0018 30 66	    mov     r0, #SYSCLK_FREQ            ; frequencia para o pTC
  77 001A 0C 5D	    bl      sysclk_init
  78 001C 60 B0	    mrs     r0, cpsr                    ; habilitar interrupcoes
  79 001E 01 61	    mov     r1, #CPSR_BIT_I
  80 0020 80 C8	    orr     r0, r0, r1
  81 0022 40 B0	    msr     cpsr, r0
  82           	
  83           	main_loop:
  84 0024 E2 5C	    bl      get_config_sw              ; verificar a posicao do switch de mode
  85 0026 11 60	    mov     r1, #1 && 0xFF
  86 0028 01 70	    movt    r1, #1 >> 8 & 0xFF
  87 002A 80 B8	    cmp     r0, r1
  88 002C 02 40	    beq     main_config_mode
  89 002E 04 5C	    bl      operation_mode
  90 0030 F9 5B	    b       main_loop
  91           	main_config_mode:
  92 0032 73 5C	    bl      config_mode
  93 0034 F7 5B	    b       main_loop
  94 0036 FF 5B	    b       .
  95           	
  96           	; Rotina:    operation_mode ----------------------------------------------------
  97           	; Descricao: *** TODO ***
  98           	; Entradas:  -
  99           	; Saidas:    -
 100           	; Efeitos:   *** TODO ***
 101           	operation_mode:
 102 0038 0E 24	    push   lr
 103 003A 04 24	    push   r4
 104 003C 05 24	    push   r5
 105           	
 106           	    ; values 1 and 0 to use in flags to save clocks ---
 107 003E 04 60	    mov     r4, #0                              ; False
 108 0040 15 60	    mov     r5, #1                              ; True
 109           	
 110           	    ; check if is the first time in operation mode --------
 111 0042 90 0E	    ldr     r0, in_operation_addr0
 112 0044 01 08	    ldrb    r1, [r0, #0]
 113 0046 90 BA	    cmp     r1, r5
 114 0048 09 40	    beq     not_first_time_in_operation_mode
 115           	    ; set in_config to 0, in_operation to 1 and in_crossing to 0
 116 004A 05 28	    strb    r5, [r0, #0]                        ; in_operation = 1
 117 004C 50 0E	    ldr     r0, in_config_addr0
 118 004E 04 28	    strb    r4, [r0, #0]                        ; in_config = 0
 119 0050 F0 0F	    ldr     r0, in_crossing_addr0
 120 0052 04 28	    strb    r4, [r0, #0]                        ; in_crossing = 0
 121           	    ; set operation first time on phase to 1 -------------
 122 0054 20 0E	    ldr     r0, op_first_time_on_phase_addr0
 123 0056 05 28	    strb    r5, [r0, #0]                        ; op_first_time_on_phase = 1
 124           	    ; turn on mode light L3 to green ---------------------
 125 0058 21 60	    mov     r1, #GREEN
 126 005A E6 5C	    bl      mode_light_set_color
 127           	not_first_time_in_operation_mode:
 128           	    ; check if a pedestrian is crossing ------------------
 129 005C 90 0F	    ldr     r0, in_crossing_addr0
 130 005E 00 08	    ldrb    r0, [r0, #0]
 131 0060 80 BA	    cmp     r0, r5
 132 0062 26 40	    beq     pedestrian_crossing
 133           	    ; check if a pedestrian pressed the button to cross --
 134 0064 BD 5C	    bl      check_pedestrian_button
 135 0066 80 BA	    cmp     r0, r5
 136 0068 1B 40	    beq     pedestrian_ask_to_cross
 137           	    ; check if is the first time in operation mode --------
 138 006A 70 0D	    ldr     r0, op_first_time_on_phase_addr0
 139 006C 01 08	    ldrb    r1, [r0, #0]
 140 006E 10 BA	    cmp     r1, r4
 141 0070 06 40	    beq     not_first_time_on_op
 142           	    ; first time in operation mode to 0 ------------------
 143 0072 04 28	    strb    r4, [r0, #0]                        ; first_time_on_op = 0
 144           	    ; turn on pedestrian light L2 to red ------------------
 145 0074 11 60	    mov     r1, #RED
 146 0076 D2 5C	    bl      pedestrian_light_set_color
 147           	    ; start timer to turn ON/OFF L1 LED -------------------
 148 0078 E8 5C	    bl      sysclk_get_ticks                    ; get actual tick number to start timer
 149 007A 01 0D	    ldr     r1, operation_time_start_tick_addr0
 150 007C 10 20	    str     r0, [r1, #0]                        ; operation_time_start_tick = sysclk_get_ticks
 151           	not_first_time_on_op:
 152           	    ; check if L1 LED are in ON or OFF phase --------------
 153 007E F0 0C	    ldr     r0, op_led_phase_addr0
 154 0080 00 08	    ldrb    r0, [r0, #0]
 155 0082 80 BA	    cmp     r0, r5
 156 0084 04 40	    beq     led_on_phase
 157           	; leds are in OFF phase
 158 0086 00 60	    mov     r0, #LIGHT_OFF                      ; turn OFF traffic light
 159 0088 C4 5C	    bl      traffic_light_set_color
 160 008A 24 5C	    bl      operation_mode_led_phases
 161 008C 1E 58	    b       end_operation_mode
 162           	led_on_phase:
 163 008E 30 60	    mov     r0, #YELLOW                          ; turn ON traffic green
 164 0090 C0 5C	    bl      traffic_light_set_color
 165 0092 20 5C	    bl      operation_mode_led_phases
 166 0094 1A 58	    b       end_operation_mode
 167           	
 168           	in_operation_addr0:
 169 0096 F3 02	    .word   in_operation
 170           	
 171           	in_config_addr0:
 172 0098 FB 02	    .word   in_config
 173           	
 174           	op_first_time_on_phase_addr0:
 175 009A FA 02	    .word   op_first_time_on_phase
 176           	
 177           	operation_time_start_tick_addr0:
 178 009C F6 02	    .word operation_time_start_tick
 179           	
 180           	op_led_phase_addr0:
 181 009E F9 02	    .word op_led_phase
 182           	
 183           	pedestrian_ask_to_cross:
 184 00A0 10 60	    mov     r0, #RED
 185 00A2 B7 5C	    bl      traffic_light_set_color
 186 00A4 20 60	    mov     r0, #GREEN
 187 00A6 BA 5C	    bl      pedestrian_light_set_color
 188 00A8 30 0D	    ldr     r0, in_crossing_addr0
 189 00AA 05 28	    strb    r5, [r0, #0]                          ; R5 = 1, in_crossing = 1
 190 00AC 2F 5C	    bl      start_pedestrian_timmer
 191 00AE 0D 58	    b       end_operation_mode
 192           	
 193           	pedestrian_crossing:
 194           	    ; check if crossing time finished ---------------------
 195 00B0 30 0F	    ldr     r0, crossing_time_start_tick_addr
 196 00B2 00 00	    ldr     r0, [r0, #0]
 197 00B4 CD 5C	    bl      sysclk_elapsed
 198 00B6 D1 0C	    ldr     r1, crossing_time_addr0
 199 00B8 11 00	    ldr     r1, [r1, #0]
 200 00BA 80 B8	    cmp     r0, r1
 201 00BC 04 48	    bhs     pedestrian_time_finished
 202           	    ; check if anothers pedestrian pressed the button to cross
 203 00BE 90 5C	    bl      check_pedestrian_button
 204 00C0 80 BA	    cmp     r0, r5
 205 00C2 EE 43	    beq     pedestrian_ask_to_cross
 206 00C4 02 58	    b       end_operation_mode
 207           	pedestrian_time_finished:
 208 00C6 40 0C	    ldr     r0, in_crossing_addr0
 209 00C8 04 28	    strb    r4, [r0, #0]                          ; R4 = 0, in_crossing = 0
 210           	
 211           	end_operation_mode:
 212 00CA 05 04	    pop     r5
 213 00CC 04 04	    pop     r4
 214 00CE 0F 04	    pop     pc
 215           	    
 216           	in_crossing_addr0:  
 217 00D0 F2 02	    .word   in_crossing
 218           	
 219           	crossing_time_addr0:
 220 00D2 E0 02	    .word   crossing_time
 221           	
 222           	; Rotina:    operation_mode_led_phases ---------------------------------------
 223           	; Descricao : *** TODO ***
 224           	; Entradas  : R0 - cor a colocar no L1 (transito)
 225           	; Saidas    : -
 226           	; Efeitos   : -
 227           	operation_mode_led_phases:
 228 00D4 0E 24	    push    lr
 229 00D6 04 24	    push    r4
 230 00D8 05 24	    push    r5
 231           	
 232 00DA 04 60	    mov     r4, #0                              ; False
 233 00DC 15 60	    mov     r5, #1                              ; True
 234           	
 235 00DE 40 0D	    ldr     r0, op_first_time_on_phase_addr
 236 00E0 01 08	    ldrb    r1, [r0, #0]
 237 00E2 90 BA	    cmp     r1, r5
 238 00E4 01 44	    bne     op_not_first_time_in_phase
 239 00E6 14 28	    strb    r4, [r1, #0]                        ; set first_time_in_phase = False
 240           	    ;bl      traffic_light_set_color
 241           	op_not_first_time_in_phase:
 242 00E8 60 0D	    ldr     r0, operation_time_start_tick_addr
 243 00EA 00 00	    ldr     r0, [r0, #0]
 244 00EC B1 5C	    bl      sysclk_elapsed
 245 00EE 51 60	    mov     r1, #BLINK_TIME
 246 00F0 80 B8	    cmp     r0, r1
 247 00F2 07 4C	    blo     operation_mode_led_phases_end
 248 00F4 A0 0C	    ldr     r0, op_led_phase_addr
 249 00F6 01 08	    ldrb    r1, [r0, #0]
 250 00F8 91 B0	    mvn     r1, r1                              ; R1 = ~r1
 251 00FA 91 C2	    and     r1, r1, r5                          ; R1 = r1 & 1, mascara para ficar só com o último bit
 252 00FC 01 28	    strb    r1, [r0, #0]                        ; op_led_phase = r1
 253 00FE 40 0C	    ldr     r0, op_first_time_on_phase_addr
 254 0100 05 28	    strb    r5, [r0, #0]                        ; first_time_in_phase = True
 255           	operation_mode_led_phases_end:
 256 0102 05 04	    pop     r5
 257 0104 04 04	    pop     r4
 258 0106 0F 04	    pop     pc
 259           	
 260           	op_first_time_on_phase_addr:
 261 0108 FA 02	    .word   op_first_time_on_phase
 262           	
 263           	op_led_phase_addr:
 264 010A F9 02	    .word   op_led_phase
 265           	
 266           	; Rotina:    start_pedestrian_timmer ------------------------------------------------
 267           	; Descricao: Inicia a contagem do tempo de travessia.
 268           	; Entradas:  -
 269           	; Saidas:    -
 270           	; Efeitos:   crossing_time_start_tick = sysclk
 271           	start_pedestrian_timmer:
 272 010C 0E 24	    push    lr
 273 010E 9D 5C	    bl      sysclk_get_ticks
 274 0110 31 0C	    ldr     r1, crossing_time_start_tick_addr
 275 0112 10 20	    str     r0, [r1, #0]
 276 0114 0F 04	    pop     pc
 277           	
 278           	operation_time_start_tick_addr:
 279 0116 F6 02	    .word operation_time_start_tick
 280           	
 281           	crossing_time_start_tick_addr:
 282 0118 F4 02	    .word crossing_time_start_tick
 283           	
 284           	; Rotina:    config_mode -------------------------------------------------------
 285           	; Descricao: *** TODO ***
 286           	; Entradas:  -
 287           	; Saidas:    -
 288           	; Efeitos:   *** TODO ***
 289           	config_mode:
 290 011A 0E 24	    push    lr
 291 011C 04 24	    push    r4
 292 011E 05 24	    push    r5
 293           	
 294           	    ; values 1 and 0 to use in flags to save clocks ---
 295 0120 04 60	    mov     r4, #0                              ; False  
 296 0122 15 60	    mov     r5, #1                              ; True
 297           	
 298           	    ; check if is the first time in config mode --------
 299 0124 E0 0D	    ldr     r0, in_config_addr
 300 0126 01 08	    ldrb    r1, [r0, #0]
 301 0128 90 BA	    cmp     r1, r5
 302 012A 0C 40	    beq     not_first_time_in_config_mode
 303           	    ; set in_config to 1, in_operation to 0 and in_crossing to 0
 304 012C 05 28	    strb    r5, [r0, #0]                            ; in_config = 1     
 305 012E A0 0D	    ldr     r0, in_operation_addr
 306 0130 04 28	    strb    r4, [r0, #0]                        ; in_operation = 0
 307 0132 90 0D	    ldr     r0, in_crossing_addr
 308 0134 04 28	    strb    r4, [r0, #0]                        ; in_crossing = 0
 309           	    ; set config first time on phase to 1 -------------
 310 0136 80 0F	    ldr     r0, conf_first_time_on_phase_addr
 311 0138 05 28	    strb    r5, [r0, #0]                        ; conf_first_time_on_phase = 1
 312           	    ; turn on mode light L3 to yellow ------------------
 313 013A 30 60	    mov     r0, #YELLOW
 314 013C 75 5C	    bl      mode_light_set_color
 315           	    ; start timer to turn ON/OFF L1 and L2 LEDS ------------
 316 013E 85 5C	    bl      sysclk_get_ticks                    ; get actual tick number to start timer
 317 0140 41 0F	    ldr     r1, config_time_start_tick_addr
 318 0142 10 20	    str     r0, [r1, #0]                        ; config_time_start_tick = sysclk_get_ticks
 319           	not_first_time_in_config_mode:
 320           	    ; check if L1 and L2 LEDS are in ON or OFF phase ---
 321 0144 30 0F	    ldr     r0, conf_leds_phase_addr
 322 0146 00 08	    ldrb    r0, [r0, #0]
 323 0148 80 BA	    cmp     r0, r5
 324 014A 04 40	    beq     config_mode_leds_on_phase
 325           	; leds are in OFF phase
 326 014C 00 60	    mov     r0, #LIGHT_OFF                      ; turn OFF traffic light
 327 014E 01 60	    mov     r1, #LIGHT_OFF                      ; turn OFF pedestrian light
 328 0150 0B 5C	    bl      config_mode_leds_phases
 329 0152 03 58	    b       config_mode_end
 330           	config_mode_leds_on_phase:
 331           	    ; check if is first time in ON phase ---------------
 332 0154 30 60	    mov     r0, #YELLOW                         ; turn ON traffic yellow
 333 0156 21 60	    mov     r1, #GREEN                          ; turn ON pedestrian green
 334 0158 07 5C	    bl      config_mode_leds_phases
 335           	config_mode_end:
 336 015A 36 5C	    bl      set_crossing_time
 337 015C 05 04	    pop     r5
 338 015E 04 04	    pop     r4
 339 0160 0F 04	    pop     pc
 340           	
 341           	in_config_addr:
 342 0162 FB 02	    .word   in_config
 343           	in_operation_addr:
 344 0164 F3 02	    .word   in_operation
 345           	in_crossing_addr:    
 346 0166 F2 02	    .word   in_crossing
 347           	
 348           	; Rotina:    config_mode_leds_phases -------------------------------------------
 349           	; Descricao : *** TODO ***
 350           	; Entradas  : R0 - cor a colocar no L1 (transito)
 351           	;             R1 - cor a colocar no L2 (peoes)
 352           	; Saidas    : -
 353           	config_mode_leds_phases:
 354 0168 0E 24	    push    lr
 355 016A 04 24	    push    r4
 356 016C 05 24	    push    r5
 357           	
 358 016E 15 60	    mov     r5, #1                              ; True
 359           	
 360 0170 B3 0D	    ldr     r3, conf_first_time_on_phase_addr
 361 0172 32 08	    ldrb    r2, [r3, #0]
 362 0174 A0 BA	    cmp     r2, r5
 363 0176 08 44	    bne     not_first_time_in_phase  
 364 0178 84 B0	    mov     r4, r1                              ; R1 = cor a colocar no L2 (peoes), guardada em R4
 365 017A 4B 5C	    bl      traffic_light_set_color             ; R0 = cor a colocar no L1 (transito)
 366 017C 00 B2	    mov     r0, r4                              ; R0 = cor a colocar no L2 (peoes)
 367 017E 4E 5C	    bl      pedestrian_light_set_color
 368 0180 00 60	    mov     r0, #0 && 0xFF
 369 0182 00 70	    movt    r0, #0 >> 8 & 0xFF
 370 0184 13 0D	    ldr     r3, conf_first_time_on_phase_addr
 371 0186 30 28	    strb    r0, [r3, #0]                        ; set first_time_in_phase = False
 372           	not_first_time_in_phase:
 373 0188 00 0D	    ldr     r0, config_time_start_tick_addr
 374 018A 00 00	    ldr     r0, [r0, #0]
 375 018C 61 5C	    bl      sysclk_elapsed
 376 018E 51 60	    mov     r1, #BLINK_TIME
 377 0190 80 B8	    cmp     r0, r1
 378 0192 07 4C	    blo     config_mode_leds_phase_end
 379 0194 B0 0C	    ldr     r0, conf_leds_phase_addr
 380 0196 01 08	    ldrb    r1, [r0, #0]
 381 0198 91 B0	    mvn     r1, r1                              ; R1 = ~r1
 382 019A 91 C2	    and     r1, r1, r5                          ; R1 = r1 & 1, mascara para ficar só com o último bit
 383 019C 01 28	    strb    r1, [r0, #0]                        ; config_leds_on = r1
 384 019E 40 0C	    ldr     r0, conf_first_time_on_phase_addr
 385 01A0 05 28	    strb    r5, [r0, #0]                        ; first_time_in_phase = True
 386           	config_mode_leds_phase_end:
 387 01A2 05 04	    pop     r5
 388 01A4 04 04	    pop     r4
 389 01A6 0F 04	    pop     pc
 390           	
 391           	conf_first_time_on_phase_addr:
 392 01A8 FF 02	    .word   conf_first_time_on_phase
 393           	config_time_start_tick_addr:
 394 01AA FC 02	    .word   config_time_start_tick
 395           	conf_leds_phase_addr:
 396 01AC FE 02	    .word   conf_leds_phase
 397           	
 398           	; Rotina:    isr ---------------------------------------------------------------
 399           	; Descricao: Incrementa o valor da variável global sysclk.
 400           	; Entradas:  -
 401           	; Saidas:    -
 402           	; Efeitos:   Incrementa o valor da variável global sysclk
 403           	isr:
 404 01AE 00 24	    push    r0
 405 01B0 01 24	    push    r1
 406           	
 407           	    ; incrementar sysclk
 408 01B2 90 0C	    ldr     r0, sysclk_addr0
 409 01B4 01 08	    ldrb    r1, [r0, #0]
 410 01B6 91 A0	    add     r1, r1, #1
 411 01B8 01 28	    strb    r1, [r0, #0]
 412           	
 413           	    ; "limpar" a interrupção no pTC
 414 01BA 40 0C	    ldr     r0, ptc_addr
 415 01BC 01 2B	    strb    r1, [r0, #PTC_TIR]
 416           	
 417 01BE 01 04	    pop     r1
 418 01C0 00 04	    pop     r0
 419 01C2 20 B0	    movs    pc, lr
 420           	
 421           	ptc_addr:
 422 01C4 40 FF	    .word PTC_ADDRESS
 423           	
 424           	sysclk_addr0:
 425 01C6 58 02	    .word sysclk_addr
 426           	
 427           	; SERVICOS ####################################################################
 428           	; Rotina:    set_crossing_time ------------------------------------------------
 429           	; Descricao: Atribui o tempo de travessia especificado à variável crossing_time.
 430           	; Entradas:  -
 431           	; Saidas:    -
 432           	; Efeitos:   crossing_time = crossing_times_array[TIME_SWS]
 433           	set_crossing_time:
 434 01C8 0E 24	    push    lr
 435 01CA 11 60	    mov     r1, #TIME_SWS && 0xFF
 436 01CC 01 70	    movt    r1, #TIME_SWS >> 8 & 0xFF
 437 01CE 45 5C	    bl      inport_read
 438 01D0 82 C0	    and     r2, r0, r1                      ; selecionar apenas bits dos Time switches
 439 01D2 40 0C	    ldr     r0, crossing_times_array_addr   
 440 01D4 01 11	    ldr     r1, [r0, r2]                    ; transferir o valor da array de times, index = r2
 441 01D6 30 0C	    ldr     r0, crossing_time_addr
 442 01D8 01 20	    str     r1, [r0, #0]                    ; crossing_time = crossing_times_array[index]
 443 01DA 0F 04	    pop     pc
 444           	
 445           	crossing_times_array_addr:
 446 01DC E2 02	    .word crossing_times_array
 447           	
 448           	crossing_time_addr:
 449 01DE E0 02	    .word crossing_time
 450           	; Rotina:    check_pedestrian_button -------------------------------------------
 451           	; Descricao: Devolve se um peão pressionou o botão de peão.
 452           	; Entradas:  -
 453           	; Saidas:    R0 - 1 se o botão de peão foi pressionado, 0 caso contrário
 454           	; Efeitos:   -
 455           	check_pedestrian_button:
 456 01E0 0E 24	    push    lr
 457 01E2 3B 5C	    bl      inport_read
 458 01E4 11 60	    mov     r1, #PEDESTRIAN_BUTTON
 459 01E6 07 5C	    bl      sw_is_pressed
 460 01E8 0F 04	    pop     pc
 461           	
 462           	; Rotina:    get_config_sw -----------------------------------------------------
 463           	; Descricao: Devolve se um peão pressionou o botão de peão.
 464           	; Entradas:  -
 465           	; Saidas:    R0 - 1 se o botão de peão foi pressionado, 0 caso contrário
 466           	; Efeitos:   -
 467           	get_config_sw:
 468 01EA 0E 24	    push    lr
 469 01EC 36 5C	    bl      inport_read
 470 01EE 11 60	    mov     r1, #CONFIG_SW && 0xFF
 471 01F0 01 70	    movt    r1, #CONFIG_SW >> 8 & 0xFF ; penso que é desnecessário
 472 01F2 80 C0	    and     r0, r0, r1
 473 01F4 0F 04	    pop     pc
 474           	
 475           	; Rotina:    sw_is_pressed -----------------------------------------------------
 476           	; Descricao: Deteta se existiu uma transicao ascendente no bit identificado em 
 477           	;            IN_PEDESTRIAN_MASK.
 478           	; Entradas:  R0 - valor do porto de entrada
 479           	;            R1 - bit a analisar
 480           	; Saidas:    R0 - 1 se houve transicao ascendente, 0 caso contrario
 481           	; Efeitos:   -
 482           	sw_is_pressed:
 483 01F6 0E 24	    push    lr
 484 01F8 80 C0	    and     r0, r0, r1                  ; r0 = sw_new_state = inport_value & pin_mask
 485 01FA A1 0C	    ldr     r1, sw_state_addr
 486 01FC 12 08	    ldrb    r2, [r1, #0]                ; r2 = sw_state
 487 01FE 00 B9	    cmp     r0, r2                      ; r0 = sw_new_state, r2 = sw_state
 488 0200 05 40	    beq     sw_is_pressed_0
 489 0202 10 28	    strb    r0, [r1, #0]                ; sw_state = sw_new_state
 490 0204 00 A8	    sub     r0, r0, #0                  ; para testar a flag Z, sw_new_state == 0
 491 0206 02 40	    beq     sw_is_pressed_0             ; se Z = 1, então r0 = 0    
 492 0208 10 60	    mov     r0, #1
 493 020A 01 58	    b       sw_is_pressed_end
 494           	sw_is_pressed_0:
 495 020C 00 60	    mov     r0, #0
 496           	sw_is_pressed_end:
 497 020E 0F 04	    pop     pc
 498           	
 499           	sw_state_addr:
 500 0210 DD 02	    .word sw_state
 501           	
 502           	; Rotina:    traffic_light_set_color -------------------------------------------
 503           	; Descricao: Atribui a cor especificada em R0 ao semáforo de trânsito (L1).
 504           	; Entradas:  R0 - Cor a atribuir ao semáforo de trânsito (L1)
 505           	; Saidas:    -
 506           	; Efeitos:   - 
 507           	traffic_light_set_color:
 508 0212 0E 24	    push    lr
 509 0214 01 B0	    mov     r1, r0                      ; r1 = color
 510 0216 30 60	    mov     r0, #TRAFFIC_LIGHT          ; r0 = TRAFFIC_LIGHT
 511 0218 38 5C	    bl      outport_write_bits
 512 021A 0F 04	    pop     pc
 513           	
 514           	; Rotina:    pedestrian_light_set_color ----------------------------------------
 515           	; Descricao: Atribui a cor especificada em R0 ao semáforo de peões (L2).
 516           	; Entradas:  R0 - Cor a atribuir ao semáforo de peões (L2)
 517           	; Saidas:    -
 518           	; Efeitos:   -
 519           	pedestrian_light_set_color:
 520 021C 0E 24	    push    lr
 521 021E 01 B0	    mov     r1, r0                      ; r1 = color
 522 0220 C0 60	    mov     r0, #PEDESTRIAN_LIGHT       ; r0 = PEDESTRIAN_LIGHT
 523 0222 11 E1	    lsl     r1, r1, #2                  ; r1 = color << 2
 524 0224 32 5C	    bl      outport_write_bits
 525 0226 0F 04	    pop     pc
 526           	
 527           	; Rotina:    mode_light_set_color ----------------------------------------------
 528           	; Descricao: Atribui a cor especificada em R0 ao semáforo de modo (L3).
 529           	; Entradas:  R0 - Cor a atribuir ao semáforo de modo (L3)
 530           	; Saidas:    -
 531           	; Efeitos:   -
 532           	mode_light_set_color:
 533 0228 0E 24	    push    lr
 534 022A 01 B0	    mov     r1, r0                      ; r1 = color
 535 022C 00 63	    mov     r0, #MODE_LIGHT             ; r0 = MODE_LIGHT
 536 022E 11 E2	    lsl     r1, r1, #4                  ; r1 = color << 4
 537 0230 2C 5C	    bl      outport_write_bits
 538 0232 0F 04	    pop     pc
 539           	
 540           	; Rotina:    sysclk_init -------------------------------------------------------
 541           	; Descricao: Inicia uma nova contagem no periferico pTC com o intervalo de
 542           	;            contagem recebido em R0, em ticks, limpando eventuais pedidos de
 543           	;            interrupcao pendentes e iniciando com o valor zero a variavel
 544           	;            global sysclk.
 545           	;            Interface exemplo: void sysclk_init( uint8_t interval );
 546           	; Entradas:  R0 - Valor do novo intervalo de contagem, em ticks.
 547           	; Saidas:    -
 548           	; Efeitos:   Inicia a contagem no periferico a partir do valor zero, limpando
 549           	;            eventuais pedidos de interrupcao pendentes e iniciando com o
 550           	;            valor zero a variavel global sysclk
 551           	sysclk_init:
 552 0234 0E 24	    push    lr
 553 0236 00 24	    push    r0              ; preservar valor dos ticks 
 554 0238 46 5C	    bl      ptc_stop        ; parar o ptc
 555 023A 4C 5C	    bl      ptc_clr_irq     ; limpar eventuais interrupts   
 556           	
 557           	    ; iniciar a varável sysclk a 0 -------------------------
 558 023C 00 60	    mov     r0, #0 && 0xFF
 559 023E 00 70	    movt    r0, #0 >> 8 & 0xFF
 560 0240 B1 0C	    ldr     r1, sysclk_addr
 561 0242 10 20	    str     r0, [r1, #0]
 562           	    
 563 0244 00 04	    pop     r0              ; repor os ticks
 564 0246 31 5C	    bl      ptc_init
 565 0248 0F 04	    pop     pc
 566           	
 567           	; Rotina:    sysclk_get_ticks --------------------------------------------------
 568           	; Descricao: Devolve o valor corrente da variável global sysclk.
 569           	;            Interface exemplo: uint16_t sysclk_get_ticks ( );
 570           	; Entradas:  -
 571           	; Saidas:    R0 - valor da variável global sysclk
 572           	; Efeitos:   -
 573           	sysclk_get_ticks:
 574 024A 61 0C	    ldr     r1, sysclk_addr
 575 024C 10 00	    ldr     r0, [r1, #0]
 576 024E 0F B7	    mov     pc, lr
 577           	
 578           	; Rotina:    sysclk_elapsed ----------------------------------------------------
 579           	; Descricao: Devolve o tempo decorrido, em ticks, desde o instante last_read
 580           	; Entradas:  R0 - valor do instante last_read
 581           	; Saidas:    R0 - tempo decorrido, em ticks, desde o instante last_read
 582           	; Efeitos:   -
 583           	sysclk_elapsed:
 584 0250 31 0C	    ldr     r1, sysclk_addr
 585 0252 12 00	    ldr     r2, [r1, #0]            ; r2 = sysclk
 586 0254 20 88	    sub     r0, r2, r0
 587 0256 0F B7	    mov     pc, lr
 588           	
 589           	sysclk_addr:
 590 0258 DE 02	    .word sysclk
 591           	
 592           	; GESTORES DE PERIFÉRICOS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 593           	;
 594           	; Gestor de periférico para o porto de entrada =================================
 595           	;
 596           	; Rotina:    inport_read -------------------------------------------------------
 597           	; Descricao: Adquire e devolve o valor corrente do porto de entrada.
 598           	;            Interface exemplo: uint8_t inport_read( );
 599           	; Entradas:  -
 600           	; Saidas:    R0 - valor adquirido do porto de entrada
 601           	; Efeitos:   -
 602           	inport_read:
 603 025A 21 0C	    ldr     r1, inport_addr
 604 025C 10 08	    ldrb    r0, [r1, #0]
 605 025E 0F B7	    mov     pc, lr
 606           	
 607           	inport_addr:
 608 0260 80 FF	    .word   INPORT_ADDRESS
 609           	
 610           	; Gestor de periférico para o porto de saída ===================================
 611           	;
 612           	; Rotina:    outport_set_bits --------------------------------------------------
 613           	; Descricao: Atribui o valor logico 1 aos bits do porto de saida identificados
 614           	;            com o valor 1 em R0. O valor dos outros bits nao e alterado.
 615           	;            Interface exemplo: void outport_set_bits( uint8_t pins_mask );
 616           	; Entradas:  R0 - Mascara com a especificacao do indice dos bits a alterar.
 617           	; Saidas:    -
 618           	; Efeitos:   Altera o valor da variavel global outport_img.
 619           	outport_set_bits:
 620 0262 0E 24	    push    lr
 621 0264 11 0E	    ldr     r1, outport_img_addr
 622 0266 12 08	    ldrb    r2, [r1, #0]
 623 0268 20 C8	    orr     r0, r2, r0
 624 026A 10 28	    strb    r0, [r1, #0]
 625 026C 17 5C	    bl      outport_write
 626 026E 0F 04	    pop     pc
 627           	
 628           	; Rotina:    outport_clear_bits ------------------------------------------------
 629           	; Descricao: Atribui o valor logico 0 aos bits do porto de saida identificados
 630           	;            com o valor 1 em R0. O valor dos outros bits nao e alterado.
 631           	;            Interface exemplo: void outport_clear_bits( uint8_t pins_mask );
 632           	; Entradas:  R0 - Mascara com a especificacao do indice dos bits a alterar.
 633           	; Saidas:    -
 634           	; Efeitos:   Altera o valor da variavel global outport_img.
 635           	outport_clear_bits:
 636 0270 0E 24	    push    lr
 637 0272 A1 0D	    ldr     r1, outport_img_addr
 638 0274 12 08	    ldrb    r2, [r1, #0]
 639 0276 10 B0	    mvn     r0, r0
 640 0278 20 C0	    and     r0, r2, r0
 641 027A 10 28	    strb    r0, [r1, #0]
 642 027C 0F 5C	    bl      outport_write
 643 027E 0F 04	    pop     pc
 644           	
 645           	; Rotina:    outport_init ------------------------------------------------------
 646           	; Descricao: Faz a iniciacao do porto de saida, nele estabelecendo o valor
 647           	;            recebido em R0.
 648           	;            Interface exemplo: void outport_init( uint8_t value );
 649           	; Entradas:  R0 - Valor a atribuir ao porto de saida.
 650           	; Saidas:    -
 651           	; Efeitos:   Altera o valor da variavel global outport_img.
 652           	outport_init:
 653 0280 0E 24	    push    lr
 654 0282 21 0D	    ldr     r1, outport_img_addr
 655 0284 10 28	    strb    r0, [r1, #0]
 656 0286 0A 5C	    bl      outport_write
 657 0288 0F 04	    pop     pc
 658           	
 659           	; Rotina:    outport-write_bits ------------------------------------------------
 660           	; Descricao: Atribui aos pinos do porto de saida identificados com o valor 1 em
 661           	;            pin_mask (R0) o valor correspondente de value (R1). O valor dos
 662           	;            restantes bits nao e alterado.
 663           	; Entradas:  R0 - Mascara com os bits a alterar.
 664           	;            R1 - Valor a atribuir aos bits identificados em R0.
 665           	; Saidas:    -
 666           	; Efeitos:   Altera o valor da variavel global outport_img.
 667           	outport_write_bits:
 668 028A 0E 24	    push    lr
 669 028C 11 C0	    and     r1, r1, r0                  ; r1 = pin_mask & value
 670 028E C2 0C	    ldr     r2, outport_img_addr
 671 0290 23 08	    ldrb    r3, [r2, #0]
 672 0292 10 B0	    mvn     r0, r0                      ; r0 = ~pin_mask
 673 0294 83 C1	    and     r3, r0, r3                  ; r3 = outport_img &= ~pin_mask
 674 0296 B0 C8	    orr     r0, r3, r1                  ; r0 = outport_img |= pin_mask & value
 675 0298 01 5C	    bl      outport_write
 676 029A 0F 04	    pop     pc
 677           	
 678           	; Rotina:    outport_write -----------------------------------------------------
 679           	; Descricao: Escreve no porto de saida o valor recebido em R0.
 680           	;            Interface exemplo: void outport_write( uint8_t value );
 681           	; Entradas:  R0 - valor a atribuir ao porto de saida.
 682           	; Saidas:    -
 683           	; Efeitos:   -
 684           	outport_write:
 685 029C 41 0C	    ldr     r1, outport_addr
 686 029E 10 28	    strb    r0, [r1, #0]
 687 02A0 32 0C	    ldr     r2, outport_img_addr
 688 02A2 20 28	    strb    r0, [r2, #0]
 689 02A4 0F B7	    mov     pc, lr
 690           	
 691           	outport_addr:
 692 02A6 C0 FF	    .word   OUTPORT_ADDRESS
 693           	
 694           	outport_img_addr:
 695 02A8 DC 02	    .word   outport_img
 696           	
 697           	; Gestor de periférico para o Pico Timer/Counter (pTC) =========================
 698           	;
 699           	; Rotina:    ptc_init ----------------------------------------------------------
 700           	; Descricao: Faz a iniciacao do periférico pTC, habilitando o seu funcionamento
 701           	;            em modo continuo e com o intervalo de contagem recebido em R0, em
 702           	;            ticks.
 703           	;            Interface exemplo: void ptc_init( uint8_t interval );
 704           	; Entradas:  R0 - Valor do novo intervalo de contagem, em ticks.
 705           	; Saidas:    -
 706           	; Efeitos:   Inicia a contagem no periferico a partir do valor zero, limpando
 707           	;            o pedido de interrupcao eventualmente pendente.
 708           	ptc_init:
 709 02AA 0E 24	    push    lr
 710 02AC 00 24	    push    r0                  ; guardar o valor do intervalo
 711 02AE 0B 5C	    bl      ptc_stop
 712 02B0 00 04	    pop     r0                  ; recuperar o valor do intervalo
 713 02B2 41 0C	    ldr     r1, ptc_addr0
 714 02B4 10 29	    strb    r0, [r1, #PTC_TMR]
 715 02B6 0E 5C	    bl      ptc_clr_irq
 716 02B8 02 5C	    bl      ptc_start
 717 02BA 0F 04	    pop     pc
 718           	
 719           	ptc_addr0:
 720 02BC 40 FF	    .word   PTC_ADDRESS
 721           	
 722           	; Rotina:    ptc_start ---------------------------------------------------------
 723           	; Descricao: Habilita a contagem no periferico pTC.
 724           	;            Interface exemplo: void ptc_start( );
 725           	; Entradas:  -
 726           	; Saidas:    -
 727           	; Efeitos:   -
 728           	ptc_start:
 729 02BE D0 0C	    ldr     r0, PTC_ADDR
 730 02C0 01 60	    mov     r1, #PTC_CMD_START
 731 02C2 01 28	    strb    r1, [r0, #PTC_TCR]
 732 02C4 0F B7	    mov     pc, lr
 733           	
 734           	; Rotina:    ptc_stop ----------------------------------------------------------
 735           	; Descricao: Para a contagem no periferico pTC.
 736           	;            Interface exemplo: void ptc_stop( );
 737           	; Entradas:  -
 738           	; Saidas:    -
 739           	; Efeitos:   O valor do registo TC do periferico e colocado a zero.
 740           	ptc_stop:
 741 02C6 90 0C	    ldr     r0, PTC_ADDR
 742 02C8 11 60	    mov     r1, #PTC_CMD_STOP
 743 02CA 01 28	    strb    r1, [r0, #PTC_TCR]
 744 02CC 0F B7	    mov     pc, lr
 745           	
 746           	; Rotina:    ptc_get_value -----------------------------------------------------
 747           	; Descricao: Devolve o valor corrente da contagem do periferico pTC.
 748           	;            Interface exemplo: uint8_t ptc_get_value( );
 749           	; Entradas:  -
 750           	; Saidas:    R0 - O valor corrente do registo TC do periferico.
 751           	; Efeitos:   -
 752           	ptc_get_value:
 753 02CE 51 0C	    ldr     r1, PTC_ADDR
 754 02D0 10 0A	    ldrb    r0, [r1, #PTC_TC]
 755 02D2 0F B7	    mov     pc, lr
 756           	
 757           	; Rotina:    ptc_clr_irq -------------------------------------------------------
 758           	; Descricao: Sinaliza o periferico pTC que foi atendido um pedido de
 759           	;            interrupção.
 760           	;            Interface exemplo: void ptc_clr_irq( );
 761           	; Entradas:  -
 762           	; Saidas:    -
 763           	; Efeitos:   -
 764           	ptc_clr_irq:
 765 02D4 20 0C	    ldr     r0, PTC_ADDR
 766 02D6 01 2B	    strb    r1, [r0, #PTC_TIR]
 767 02D8 0F B7	    mov     pc, lr
 768           	
 769           	PTC_ADDR:
 770 02DA 40 FF	    .word   PTC_ADDRESS
 771           	
 772           	
 773           	; ##############################################################################
 774           	; Seccao:    data
 775           	; Descricao: Guarda as variáveis globais
 776           	;
 777           	    .data
 778           	outport_img:
 779 02DC 00   	    .space  1
 780           	
 781           	sw_state:
 782 02DD 00   	    .space  1
 783           	
 784           	sysclk:
 785 02DE 00   	    .space  2
 785 02DF 00
 786           	
 787           	; operation mode variables -----------------------------------------------------
 788           	crossing_time:
 789 02E0 64 00	    .word 100
 790           	
 791           	crossing_times_array:
 792          	    .word  100, 200, 300, 400, 500, 600, 600, 600 ; 1 tick = 100ms / 10 ticks = 1s
 792 02E2 64 00 C8 00 2C 01 90 01 F4 01 58 02 58 02 58 02
 793           	    ; hex: 063, 0C8, 12C, 190, 1F4, 258, 258, 258
 794           	
 795           	in_crossing:     ; flag para saber se ha peao a atravessar
 796 02F2 00	    .byte 0
 797           	
 798           	in_operation:    ; flag para saber se o modo de operacao esta ativo
 799 02F3 00	    .byte 0      ; 0 - 1a entrada em modo operação, 1 - reentradas vindas do main_loop
 800           	
 801           	crossing_time_start_tick: ; para ter o valor do tick em que o peao comecou a atravessar
 802 02F4 00   	    .space 2
 802 02F5 00
 803           	
 804           	operation_time_start_tick: ; para ter o valor do tick em que o semaforo de transito apagou ou acendeu
 805 02F6 00   	    .space 2
 805 02F7 00
 806           	
 807           	first_time_on_op:  ; flag para saber se e para acender ou nao o led dos peoes
 808 02F8 01	    .byte 1
 809           	
 810           	op_led_phase:      ; flag para saber se e para acender ou nao o led do transito
 811 02F9 01	    .byte 1
 812           	
 813           	op_first_time_on_phase: ; flag para saber se e a primeira vez que os leds estao acesos
 814 02FA 01	    .byte 1
 815           	
 816           	; config mode variables --------------------------------------------------------
 817           	in_config:       ; flag para saber se o modo de configuracao esta ativo
 818 02FB 00	    .byte 0      ; 0 - 1a entrada em modo operação, 1 - reentradas vindas do main_loop
 819           	
 820           	config_time_start_tick: ; para ter o valor do tick em que os semaforos apagaram ou acenderam
 821 02FC 00   	    .space 2
 821 02FD 00
 822           	
 823           	conf_leds_phase:  ; flag para saber se e para acender ou nao os leds
 824 02FE 01	    .byte 1
 825           	
 826           	conf_first_time_on_phase: ; flag para saber se e a primeira vez que os leds estao acesos
 827 02FF 01	    .byte 1
 828           	
 829           	; ##############################################################################
 830           	; Seccao:    stack
 831           	; Descricao: Implementa a pilha com o tamanho definido pelo simbolo STACK_SIZE
 832           	;
 833           	    .stack
 834 0300 00   	    .space  STACK_SIZE
 834 .... ..
 834 033F 00
 835           	stack_top:
 835           	
