# Assembly Language Programming



*Assembly language* is the human-readable representation of the computer’s native language. Each assembly language instruction specifies both the operation to perform and the operands on which to operate.

## Instructions

- Rd, Rm - (R0 - R15)
- Rn - (R0 - R7)

### Arithmetic

| **Operation** | **Assembly**                 | Flags   | Notes                |
| ------------- | ---------------------------- | ------- | -------------------- |
| Add           | ```add Rd, Rn, #immed_4```   | N Z C V | Rd = Rn + immed_4    |
| Add           | ```add Rd, Rn, Rm```         | N Z C V | Rd = Rn + Rm         |
| Add w/ carry  | ```adc Rd, Rn, Rm```         | N Z C V | Rd = Rn + Rm + carry |
| Sub           | ``` sub Rd, Rn, #immed_4 ``` | N Z C V | Rd = Rn - immed_4    |
| Sub           | ``` sub Rd, Rn, Rm ```       | N Z C V | Rd = Rn - Rm         |
| Sub w/ carry  | ``` sbc Rd, Rn, Rm ```       | N Z C V | Rn = Rn - Rm - carry |



### Logic

| **Operation**      | Assembly               | Flags | Notes          |
| ------------------ | ---------------------- | ----- | -------------- |
| AND                | ``` and Rd, Rn, Rm ``` | N Z   | Rd = Rn AND Rm |
| OR                 | ``` orr Rd, Rn, Rm ``` | N Z   | Rd = Rn OR Rm  |
| XOR (Exclusive OR) | ```eor Rd, Rn, Rm ```  | N Z   | Rd = Rn XOR Rm |



### Shifting

| **Operation**          | Assembly                        | Flags | Notes |
| ---------------------- | ------------------------------- | ----- | ----- |
| Logical shift left     | ``` lsl Rd, Rn, #<immed_4> ```  | N Z C |       |
| Logical shift right    | ``` lsr Rd, Rn , #<immed_4> ``` | N Z C |       |
| Arithmetic shift right | ``` asr Rd, Rn, #<immed_4> ```  | N Z C |       |
| Rotate right           | ``` ror Rd, Rn, #<immed_4> ```  | N Z C |       |
| Rotate right extended  | ``` rrx Rd, Rn ```              | N Z C |       |



### Comparison

| **Operation** | Assembly           | Flags   | Notes          |
| ------------- | ------------------ | ------- | -------------- |
| Compare       | ``` cmp Rn, Rm ``` | N Z C V | CPSR = Rn - Rm |



### Data transfer between registers

| **Operation**         | Assembly                    | Flags   | Notes                   |
| --------------------- | --------------------------- | ------- | ----------------------- |
| Move                  | ``` mov Rd, #<immmed_8> ``` |         | Rd = immed_8            |
| Move                  | ``` mov Rd, Rm ```          |         | Rd = Rm                 |
| NOT                   | ``` mvn Rd, Rm ```          | N Z     | Rd = ! Rm               |
| Move to higher byte   | ``` movt Rd, #<immed_8> ``` |         | Rd[15:8] = immed_8      |
| Move and restore CPSR | ``` movs PC, LR ```         | N Z C V | PC = LC & CPSR = SPSR   |
| Move register to CPSR | ``` msr Rd, CPSR ```        |         | CPSR = Rd (bits 0 to 5) |
| Move register to SPSR | ``` msr Rd, SPSR ```        |         | SPSR = Rd (bits 0 to 5) |
| Move CPSR to register | ``` mrs Rd, CPSR ```        |         | Rd = CPSR               |
| Move SPSR to register | ``` mrs Rd, SPSR ```        |         | Rd = SPSR               |



### Memory data transfer

| **Operation** | Assembly                        | Flags | Notes                                       |
| ------------- | ------------------------------- | ----- | ------------------------------------------- |
| Load word     | `` ldr Rd, labelS ``            |       | Rd = addr(labelS), labelS +- 128KB distance |
| Load word     | ``` ldr Rd, [Rn, #immed_4] ```  |       | Rd = addr(Rn + immed_4)                     |
| Load word     | ``` ldr Rd, [Rn, Rm] ```        |       | Rd = addr(Rn + Rm)                          |
| Load byte     | ``` ldrb Rd, [Rn, #immed_4] ``` |       | Rd[7:0] = addr(Rn + immed_4), Rd[15:8] = 0  |
| Load byte     | ``` ldrb Rd, [Rn, Rm] ```       |       | Rd[7:0] = addr(Rn + Rm), Rd[15:8] = 0       |
| Store word    | ``` str Rd, [Rn, #immed_4] ```  |       | addr(Rn + immed_4) = Rd                     |
| Store word    | ```str Rd, [Rn, Rm] ```         |       | addr(Rn + Rm) = Rd                          |
| Store byte    | ``` strb Rd, [Rn, #immed_4] ``` |       | addr(Rn + immed_4) = Rd[7:0]                |
| Store byte    | ``` strb Rd, [Rn, Rm] ```       |       | addr(Rn + Rm) = Rd[7:0]                     |



### Stack manipulation

| **Operation** | Assembly | Flags | Notes                  |
| ------------- | -------- | ----- | ---------------------- |
| Push          | push Rm  |       | SP = SP - 2, [SP] = Rm |
| Pop           | pop Rd   |       | SP = SP + 2, Rd = [SP] |



### Control

| **Operation**                                 | Assembly                              | Flags | Notes               |
| --------------------------------------------- | ------------------------------------- | ----- | ------------------- |
| Branch                                        | ``` b label ```                       |       | PC = label          |
| Branch with link                              | ``` bl label ```                      |       | LR = PC, PC = label |
| Branch if equal / zero set                    | ``` beq label ``` / ```bzs label ```  |       | PC = label          |
| Branch if not equal / zero clear              | ``` bne label ``` / ``` bzc label ``` |       | PC  = label         |
| Branch if signed less than                    | ``` blt label ```                     |       | PC  = label         |
| Branch if signed greater than or equal        | ``` bge label ```                     |       | PC  = label         |
| Branch if unsigned higher or same / carry set | ``` bhs label ``` / ``` bcs label ``` |       | PC  = label         |
| Branch if unsigned lower / carry clear        | ``` blo label ``` / ``` bcc label ``` |       | PC  = label         |

label - must refer to an address +-1 KB of distance



## Structured programming

![image-20240311143641421](../images/image-20240311143641421.png)

In assembly, the modules that make up a program are called **routines**.

If a routine does not invoke any other routine, it is called a **leaf routine**.



### Register conventions

| Name     | Use                                         |
| -------- | ------------------------------------------- |
| R0       | Argument / return value/ temporary variable |
| R1 - R3  | Argument / temporary variables              |
| R4 - R12 | Saved variables                             |
| R13 (SP) | Stack Pointer                               |
| R14 (LR) | Link Register                               |
| R15 (PC) | Program Counter                             |



Example of how to Invoke a routine located at an address at a distance more than ± 1KByte

```assembly
main:
	...					; ry = [r0..r7]
	mov ry, pc			; ry = 0x0120
	add lr, ry, #4		; lr = 0x0124
	ldr pc, dummy_addr	; pc = 0x1C34
	...
	...
dummy_addr:
	.word dummy			; [0x016C] = 0x1C34
    ...
    ...
 dummy:
 	mov pc, lr
```



> First 4 arguments of a function must be passed in the first 4 registers (R0 - R3), next arguments must by passed in the stack

### Example exercise

Develop in P16 assembly, a function to perform the multiplication of two natural numbers **M** and **m**, encoded with 8 bits, using the algorithm of successive additions

```c
uint16_t mul16 (uint8_t M, uint8_t m) {
    uint16_t p = 0;
    while (m > 0) {
        p = p + M;
        m = m - 1;
    } 
    
    return p
}

void main () {
    uint8_t M = 4;
    uint8_t m = 8;
    uint16_t p = mul16(M, m);
}
```



```assembly
; -----------------------------------------------------------------------------
; Ficheiro:  aula9.S
; Descricao: Funcao mul16.
; Autor:     Jorge Fonseca (jorge.fonseca@isel.pt)
; Data:      08-03-2024
; -----------------------------------------------------------------------------

main:
	ldr	 r0,M_addr	;r0 = @M
	ldrb r0,[r0,#0]	;r0 = M
	ldr	 r1,m_addr	;r1 = @m
	ldrb r1,[r1,#0]	;r1 = m
	bl	 mul16
	ldr	 r1,P_addr	;r1 = @P
	str	 r0,[r1,#0]	;r1 = P
	b	 .

M_addr:
	.word M
m_addr:
	.word m
P_addr:
	.word P

; uint16_t mul16 ( uint16_t M(r0), uint16_t m(r1) )
; r0 is the M parameter
; r1 is the m parameter	
mul16:
	mov	r2, #0		; p = 0
while:
	mov	r3, #0		
	cmp	r3, r1		; 0 < m
	bhs	while_end
	add	r2, r2, r0	; p = p + M
	sub	r1, r1, #1	; m = m - 1
	b	while
while_end:
	mov	r0, r2		; r0 = p
	mov	pc, lr

m:
	.byte	8
M:
	.byte	4
P:
	.word	0
```



## Stack

A stack is a linear list-type data structure, where all the operations of insertion and removal are performed by the same end, called the top.

Normally, stacks support two operations:

- **Push**, which inserts a new element at the top of the stack, increasing its size;
- **Unstacking (pop)**, which removes the element from the top of the stack, decreasing its size.

Due to their characteristics, stacks are particularly useful when you want to store, temporarily, data that will be used shortly: local variables, arguments of routines, return values of routines, etc. Processors therefore provide support for stack deployment.

Can be implemented using registers or in memory, most usual solution. When deployed in memory, the stack
corresponds to a set of contiguous memory positions. the stack access is managed by a special register, the **stack pointer (SP)**.



### Types of stack implementation

**Full ascending**

The stack grows in the direction of the higher memory addresses (ascending) 

- In each stacking operation, the value of the stack pointer (SP) is incremented
- Stack pointer (SP) always references a stack position with data (full)

**Empty ascending**

The stack grows in the direction of the higher memory addresses (ascending) 

- In each stacking operation, the value of the stack pointer (SP) is incremented
- Stack pointer (SP) always references a stack an empty position (empty)

**Full descending**

The stack grows in the direction of the lower memory addresses (descending) 

- In each stacking operation, the value of the stack pointer (SP) is decremented
- Stack pointer (SP) always references a stack position with data (full)

**Empty descending**

The stack grows in the direction of the lower memory addresses (descending) 

- In each stacking operation, the value of the stack pointer (SP) is decremented
- Stack pointer (SP) always references a stack an empty position (empty)

> Note : P16 uses the stack in memory with the full descending philosophy. Supports operations of push and pop. SP is on the R13 and the access is exclusively in 16 bits



## Constants usage

The use of numeric constants embedded in the source code has several disadvantages: causes a lot of errors, decreases the readability of the code, complicates code maintenance, makes it difficult to reuse the code.

To mitigate these problems, it is desirable to associate the numerical constants used by the programs to symbols that are used in the writing of the source code.

```assembly
.equ name, val
```

Constants defined using the ```.equ``` directive do not take up memory space, but exist only in the compile-time program

Examples:

```c
# define MY_CONST 8

char var1 = MY_CONST;
uint8_t var2 = MY_CONST;
int8_t var3 = MY_CONST;
int16_t var4 = MY_CONST;
uint16_t var5 = MY_CONST;
```



```assembly
.equ MY_CONST, 8

mov  r0, #MY_CONST & 0xFF 				; char
mov  r1, #MY_CONST & 0xFF 				; uint8_t
mov  r2, #MY_CONST & 0xFF				; int8_t, note next lsl and asr to keep the signal
lsl  r2, r2, #8
asr  r2, r2, #8
mov  r3, #MY_CONST & 0xFF				; int16_t
movt r3, #(MY_CONST >> 8) & 0xFF
mov  r4, #MY_CONST & 0xFF 				; uint16_t
movt r4, #(MY_CONST >> 8) & 0xFF
```



## Typical organization of routines

### Non-leaf routines

``` assembly
routine:
	; Prologue
	;		Save LR in stack
	; 		Save R4...R12 in stack
	; 		Copy R0...R3 to R4...R12
	
	; Algorithm implementation
	
	; Epilogue
	;		Put return value in R0
	; 		Recover R4...R12 from stack
	; 		Recover LR from stack
	; 		Return from the routine
```



### Leaf routines

```assembly
leaf_routine:
	; Prologue
	; 		Save R4...R12 in stack
	
	; Algorithm implementation
	
	; Epilogue
	; 		Put return value in R0
	; 		Recover R4...R12 from stack 
	; 		Return from the routine
```



## Variables usage

The space used by a variable needs to be reserved before the first time it is used.

The reservation of this space can be made using:

- Processor registers
  - **+** Shorter access time (typically one clock cycle)
  - **-** Available space is very limited (on the order of tens of bytes)
- Main Memory
  - **+** Available space is much larger (in the order of gigabytes)
  - **-** Access time is much higher (tens or hundreds of clock cycles)

To define a variable in memory, a set of contiguous memory positions are reserved, in sufficient number to store the number of bits that make up the data type, and by associating its base address with the symbol corresponding to the name of the variable.

The data is arranged in memory from the address associated with the variable, where organized as a sequence of contiguous bytes.

In a program there can be **global** and **local** variables.

- Global variables exist throughout the execution of the program, being accessible in any part of the program, as they may be used or modified by all other functions.
- Local variables are declared within the block of a function, so they only exist while that function is running and are accessible only by that function.

A global variable can have an initial value, which corresponds to a constant whose value is set at compile time. This value is written to memory only during the process of loading the program into memory.

In the *P16 assembly language*, there are several *p16as* directives to reserve and start memory positions, i.e. define the data (variables and constants) of the program.

| **Directive** | **Parameters**      | **Description** |
| ------------- | ------------------- | --------------- |
| **.word**     | val1[, val2, ...]   | **TODO**        |
| **.byte**     | val1[, val2, ...]   |                 |
| **.ascii**    | char1[, char2, ...] |                 |
| **.asciz**    | char1[, char2, ...] |                 |
| **.space**    | dim val             |                 |

For local variables its used the processor registers. In the case of necessity to use the memory its possible to use the instructions ```ldr``` \ ```ldrb```, ```str``` \ ```strb```, and eventually ```push``` and ```pop``` .

Examples:

``` c
char    var1 = 'a';
int8_t  var2 = 1;
int16_t var3 = -1;
int32_t var4 = 0x12345678
```

```assembly
mov  r0, #'a'		; r0 = var1
mov  r1, #1			; r1 = var2
mov	 r2, #0xFFFF	; r2 = var3 (LSB)
movt r2, #0xFFFF	; r2 = var3 (MSB)
mov  r3, #0x78		; r3 = var4[7..0]
movt r3, #0x56		; r3 = var4[15..8]
mov  r4, #0x34		; r4 = var4[23..16]
movt r4, #0x12		; r4 = var4[31..24]
```

